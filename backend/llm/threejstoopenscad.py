import base64
import httpx
import anthropic

client = anthropic.Anthropic(
    # defaults to os.environ.get("ANTHROPIC_API_KEY")
)

threejs_output = "// Pine Tree Model\n\n// Scene setup\nconst scene = new THREE.Scene();\nconst camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\nconst renderer = new THREE.WebGLRenderer({ antialias: true });\nrenderer.setSize(window.innerWidth, window.innerHeight);\nrenderer.setClearColor(0x87CEEB); // Light blue sky\ndocument.body.appendChild(renderer.domElement);\n\n// Materials\nconst trunkMaterial = new THREE.MeshPhongMaterial({ \n  color: 0x8B4513,\n  flatShading: true\n});\n\nconst foliageMaterial = new THREE.MeshPhongMaterial({ \n  color: 0x228B22,\n  flatShading: true\n});\n\n// Create tree group\nconst tree = new THREE.Group();\n\n// Create trunk\nconst trunkGeometry = new THREE.BoxGeometry(1, 4, 1);\nconst trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);\ntrunk.position.y = 2;\ntree.add(trunk);\n\n// Create foliage layers\nconst createFoliageLayer = (radius, height, y) => {\n  const geometry = new THREE.ConeGeometry(radius, height, 8);\n  const layer = new THREE.Mesh(geometry, foliageMaterial);\n  layer.position.y = y;\n  return layer;\n};\n\n// Add foliage layers\nconst layers = [\n  { radius: 4, height: 2, y: 4 },\n  { radius: 3.5, height: 2, y: 5.5 },\n  { radius: 3, height: 1.8, y: 6.8 },\n  { radius: 2.5, height: 1.6, y: 8 },\n  { radius: 2, height: 1.4, y: 9 },\n  { radius: 1.5, height: 1.2, y: 10 },\n  { radius: 1, height: 1, y: 11 }\n];\n\nlayers.forEach(layer => {\n  tree.add(createFoliageLayer(layer.radius, layer.height, layer.y));\n});\n\nscene.add(tree);\n\n// Lighting\nconst ambientLight = new THREE.AmbientLight(0x404040, 1);\nscene.add(ambientLight);\n\nconst directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\ndirectionalLight.position.set(5, 5, 5);\nscene.add(directionalLight);\n\n// Camera position\ncamera.position.set(15, 15, 15);\ncamera.lookAt(scene.position);\n\n// Orbit controls\nconst controls = new THREE.OrbitControls(camera, renderer.domElement);\ncontrols.enableDamping = true;\ncontrols.dampingFactor = 0.05;\n\n// Animation\nlet time = 0;\nfunction animate() {\n  requestAnimationFrame(animate);\n  \n  // Subtle sway animation\n  time += 0.01;\n  tree.rotation.y = Math.sin(time) * 0.05;\n  \n  // Slight tilt animation for foliage\n  tree.children.forEach((child, index) => {\n    if (index > 0) { // Skip trunk\n      child.rotation.z = Math.sin(time + index) * 0.02;\n    }\n  });\n  \n  controls.update();\n  renderer.render(scene, camera);\n}\nanimate();\n\n// Handle window resizing\nwindow.addEventListener('resize', function() {\n  camera.aspect = window.innerWidth / window.innerHeight;\n  camera.updateProjectionMatrix();\n  renderer.setSize(window.innerWidth, window.innerHeight);\n});"
original_prompt = "Generate a model of pine tree."
image_url = "https://media.sketchfab.com/models/c1d140fc15bd40928989d0ca79365e13/thumbnails/465f602c45454d8f813cc54198930c24/76d9c131a5314d98bf271617a3a43378.jpeg"
image_media_type = "image/jpeg"
image_data = base64.standard_b64encode(httpx.get(image_url).content).decode("utf-8")

# Replace placeholders like {{THREEJS_OUTPUT}} with real values,
# because the SDK does not support variables.
message = client.messages.create(
    model="claude-3-5-sonnet-20241022",
    max_tokens=8192,
    temperature=0,
    messages=[
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "<examples>\n<example>\n<THREEJS_OUTPUT>\n// Dining Table Model\n// All dimensions in centimeters\n\n// Scene setup\nconst scene = new THREE.Scene();\nconst camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\nconst renderer = new THREE.WebGLRenderer();\nrenderer.setSize(window.innerWidth, window.innerHeight);\ndocument.body.appendChild(renderer.domElement);\n\n// Dimensions\nconst tableLength = 150;\nconst tableWidth = 90;\nconst tableHeight = 75;\nconst topThickness = 4;\nconst legWidth = 8;\nconst legInset = 5;\nconst supportHeight = 5;\nconst supportThickness = 3;\n\n// Materials\nconst woodTexture = new THREE.TextureLoader().load('wood_texture.jpg');\nconst woodMaterial = new THREE.MeshStandardMaterial({ map: woodTexture });\n\n// Table components\nfunction createTabletop() {\n  const geometry = new THREE.BoxGeometry(tableLength, topThickness, tableWidth);\n  return new THREE.Mesh(geometry, woodMaterial);\n}\n\nfunction createLeg() {\n  const geometry = new THREE.BoxGeometry(legWidth, tableHeight - topThickness, legWidth);\n  return new THREE.Mesh(geometry, woodMaterial);\n}\n\nfunction createSupportRail(length) {\n  const geometry = new THREE.BoxGeometry(length, supportHeight, supportThickness);\n  return new THREE.Mesh(geometry, woodMaterial);\n}\n\n// Create table\nconst table = new THREE.Object3D();\n\n// Tabletop\nconst tabletop = createTabletop();\ntabletop.position.y = tableHeight - topThickness / 2;\ntable.add(tabletop);\n\n// Legs\nconst legPositions = [\n  { x: -tableLength/2 + legInset + legWidth/2, z: -tableWidth/2 + legInset + legWidth/2 },\n  { x: tableLength/2 - legInset - legWidth/2, z: -tableWidth/2 + legInset + legWidth/2 },\n  { x: -tableLength/2 + legInset + legWidth/2, z: tableWidth/2 - legInset - legWidth/2 },\n  { x: tableLength/2 - legInset - legWidth/2, z: tableWidth/2 - legInset - legWidth/2 }\n];\n\nlegPositions.forEach(pos => {\n  const leg = createLeg();\n  leg.position.set(pos.x, (tableHeight - topThickness) / 2, pos.z);\n  table.add(leg);\n});\n\n// Support rails\nconst longRailLength = tableLength - 2 * legInset - 2 * legWidth;\nconst shortRailLength = tableWidth - 2 * legInset - 2 * legWidth;\n\nconst longRailPositions = [\n  { x: 0, z: -tableWidth/2 + legInset + legWidth/2 },\n  { x: 0, z: tableWidth/2 - legInset - legWidth/2 }\n];\n\nconst shortRailPositions = [\n  { x: -tableLength/2 + legInset + legWidth/2, z: 0 },\n  { x: tableLength/2 - legInset - legWidth/2, z: 0 }\n];\n\nlongRailPositions.forEach(pos => {\n  const rail = createSupportRail(longRailLength);\n  rail.position.set(pos.x, tableHeight - topThickness - supportHeight - 20, pos.z);\n  table.add(rail);\n});\n\nshortRailPositions.forEach(pos => {\n  const rail = createSupportRail(shortRailLength);\n  rail.rotation.y = Math.PI / 2;\n  rail.position.set(pos.x, tableHeight - topThickness - supportHeight - 20, pos.z);\n  table.add(rail);\n});\n\nscene.add(table);\n\n// Lighting\nconst ambientLight = new THREE.AmbientLight(0x404040);\nscene.add(ambientLight);\n\nconst directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);\ndirectionalLight.position.set(1, 1, 1);\nscene.add(directionalLight);\n\nconst pointLight1 = new THREE.PointLight(0xffffff, 0.5);\npointLight1.position.set(0, 100, 0);\nscene.add(pointLight1);\n\nconst pointLight2 = new THREE.PointLight(0xffffff, 0.3);\npointLight2.position.set(100, 0, 100);\nscene.add(pointLight2);\n\n// Camera position\ncamera.position.set(150, 100, 150);\ncamera.lookAt(scene.position);\n\n// Orbit controls\nconst controls = new THREE.OrbitControls(camera, renderer.domElement);\n\n// Animation\nfunction animate() {\n  requestAnimationFrame(animate);\n  table.rotation.y += 0.002;\n  controls.update();\n  renderer.render(scene, camera);\n}\nanimate();\n\n// Handle window resizing\nwindow.addEventListener('resize', function() {\n  camera.aspect = window.innerWidth / window.innerHeight;\n  camera.updateProjectionMatrix();\n  renderer.setSize(window.innerWidth, window.innerHeight);\n});\n</THREEJS_OUTPUT>\n<ORIGINAL_PROMPT>\nCreate a dining table\n</ORIGINAL_PROMPT>\n<ideal_output>\n<conversion_analysis>\n1. ThreeJS Code Structure Breakdown:\n   - Scene setup (camera, renderer)\n   - Dimension definitions\n   - Material setup (wood texture)\n   - Table component functions (tabletop, leg, support rail)\n   - Table assembly\n   - Lighting setup\n   - Camera positioning and controls\n   - Animation loop\n\n2. Key Components and Dimensions:\n   - Tabletop: 150cm x 90cm x 4cm\n   - Legs: 8cm x 8cm x 71cm (4 pieces)\n   - Support Rails: Long (126cm) and Short (66cm)\n   - Table Height: 75cm\n\n3. Potential Conversion Challenges:\n   - Coordinate system differences (ThreeJS uses center origin, OpenSCAD typically uses corner origin)\n   - Complex positioning of legs and support rails\n   - No direct equivalent for materials and lighting in OpenSCAD\n\n4. Positioning Logic Strategy:\n   - Convert ThreeJS center-origin coordinates to OpenSCAD corner-origin\n   - Carefully calculate leg positions relative to table edges\n   - Position support rails using the same logic as in ThreeJS\n\n5. Overall Conversion Process:\n   - Define all dimensions as variables, converting cm to mm\n   - Create modules for repeated components (legs, rails)\n   - Use translate() to position components accurately\n   - Implement positioning logic that matches ThreeJS coordinates\n   - Use union() to combine all components into a single model\n</conversion_analysis>\n\n<model_planning>\nConversion Process and Challenges:\n\n1. Dimension Conversion:\n- Converted all dimensions from centimeters to millimeters\n- Maintained the same proportions as the original ThreeJS model\n\n2. Structural Changes:\n- Replaced ThreeJS's mesh-based approach with OpenSCAD's constructive solid geometry (CSG)\n- Used basic cube primitives for all components as they matched the original geometric shapes\n- Implemented modules for reusable components (legs and support rails)\n\n3. Main Challenges:\n- Coordinate System Differences: Had to adjust the positioning logic since OpenSCAD uses a different coordinate system than ThreeJS\n- Position Calculations: Needed to carefully calculate the positions of legs and support rails relative to the table dimensions\n- No Direct Material Support: Removed material and texture information as OpenSCAD doesn't support these features\n\n4. Optimizations:\n- Used a loop for creating table legs instead of individual placement\n- Created modular components for better code organization and reusability\n- Added variables for all dimensions to make the design easily modifiable\n\n5. Additional Considerations:\n- Added $fn variable for controlling curve resolution (though not strictly necessary for this model)\n- Organized code with clear sections and comments for better readability\n- Positioned the entire model in positive coordinate space for easier 3D printing if needed\n\nThe resulting OpenSCAD model maintains the same structural integrity and proportions as the original ThreeJS model, though without the visual elements like materials and lighting.\n</model_planning>\n\n<openscad_output>\n// Dining Table in OpenSCAD\n// All dimensions in millimeters (converted from cm)\n\n// Global resolution\n$fn = 50;\n\n// Table dimensions\ntableLength = 1500; // 150cm\ntableWidth = 900;   // 90cm\ntableHeight = 750;  // 75cm\ntopThickness = 40;  // 4cm\nlegWidth = 80;      // 8cm\nlegInset = 50;      // 5cm\nsupportHeight = 50;  // 5cm\nsupportThickness = 30; // 3cm\n\n// Module for table leg\nmodule table_leg() {\n    cube([legWidth, legWidth, tableHeight - topThickness]);\n}\n\n// Module for support rail\nmodule support_rail(length) {\n    cube([length, supportThickness, supportHeight]);\n}\n\n// Module for complete table\nmodule dining_table() {\n    // Tabletop\n    translate([-tableLength/2, -tableWidth/2, tableHeight - topThickness])\n        cube([tableLength, tableWidth, topThickness]);\n    \n    // Legs\n    leg_positions = [\n        [-tableLength/2 + legInset, -tableWidth/2 + legInset, 0],\n        [tableLength/2 - legInset - legWidth, -tableWidth/2 + legInset, 0],\n        [-tableLength/2 + legInset, tableWidth/2 - legInset - legWidth, 0],\n        [tableLength/2 - legInset - legWidth, tableWidth/2 - legInset - legWidth, 0]\n    ];\n    \n    for (pos = leg_positions) {\n        translate(pos) table_leg();\n    }\n    \n    // Support rails\n    longRailLength = tableLength - 2 * legInset - 2 * legWidth;\n    shortRailLength = tableWidth - 2 * legInset - 2 * legWidth;\n    railHeight = tableHeight - topThickness - supportHeight - 200; // 20cm below top\n    \n    // Long rails\n    translate([-longRailLength/2, -tableWidth/2 + legInset + legWidth/2 - supportThickness/2, railHeight])\n        support_rail(longRailLength);\n    translate([-longRailLength/2, tableWidth/2 - legInset - legWidth/2 - supportThickness/2, railHeight])\n        support_rail(longRailLength);\n    \n    // Short rails\n    translate([-tableLength/2 + legInset + legWidth/2 - supportThickness/2, -shortRailLength/2, railHeight])\n        rotate([0, 0, 90])\n            support_rail(shortRailLength);\n    translate([tableLength/2 - legInset - legWidth/2 - supportThickness/2, -shortRailLength/2, railHeight])\n        rotate([0, 0, 90])\n            support_rail(shortRailLength);\n}\n\n// Create the table\ndining_table();\n</openscad_output>\n</ideal_output>\n</example>\n<example>\n<THREEJS_OUTPUT>\n// Hollow Cylinder Model\n// Dimensions: Outer radius 20 units, Wall thickness 5 units, Height 40 units\n\n// Scene setup\nconst scene = new THREE.Scene();\nconst camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\nconst renderer = new THREE.WebGLRenderer();\nrenderer.setSize(window.innerWidth, window.innerHeight);\ndocument.body.appendChild(renderer.domElement);\n\n// Cylinder\nconst outerRadius = 20;\nconst innerRadius = 15; // outer radius - wall thickness\nconst height = 40;\nconst radialSegments = 32;\nconst cylinderGeometry = new THREE.CylinderGeometry(outerRadius, outerRadius, height, radialSegments, 1, true, 0, Math.PI * 2);\nconst cylinderMaterial = new THREE.MeshStandardMaterial({ \n  color: 0x888888, \n  metalness: 0.8,\n  roughness: 0.2,\n  side: THREE.DoubleSide\n});\nconst cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);\nscene.add(cylinder);\n\n// Lighting\nconst ambientLight = new THREE.AmbientLight(0x404040);\nscene.add(ambientLight);\nconst directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);\ndirectionalLight.position.set(1, 1, 1);\nscene.add(directionalLight);\nconst pointLight = new THREE.PointLight(0xffffff, 0.5);\npointLight.position.set(0, 0, 0);\nscene.add(pointLight);\n\n// Camera position\ncamera.position.z = 100;\n\n// Orbit controls\nconst controls = new THREE.OrbitControls(camera, renderer.domElement);\n\n// Animation\nfunction animate() {\n  requestAnimationFrame(animate);\n  cylinder.rotation.y += 0.01;\n  controls.update();\n  renderer.render(scene, camera);\n}\nanimate();\n\n// Handle window resizing\nwindow.addEventListener('resize', function() {\n  camera.aspect = window.innerWidth / window.innerHeight;\n  camera.updateProjectionMatrix();\n  renderer.setSize(window.innerWidth, window.innerHeight);\n});\n</THREEJS_OUTPUT>\n<ORIGINAL_PROMPT>\nGenerate a model of a hollow cylinder with a 5mm wall thickness\n</ORIGINAL_PROMPT>\n<ideal_output>\n<conversion_analysis>\n1. ThreeJS Code Structure Breakdown:\n- Main geometric element is a hollow cylinder\n- Uses CylinderGeometry with both outer and inner radius\n- Key dimensions: \n  * Outer radius: 20 units\n  * Inner radius: 15 units (derived from 5-unit wall thickness)\n  * Height: 40 units\n  * 32 radial segments for smooth cylindrical surface\n\n2. Key Components:\n- Single hollow cylinder created using CylinderGeometry\n- No complex positioning needed as it's centered at origin\n- Material properties (not relevant for OpenSCAD conversion)\n\n3. Conversion Challenges:\n- ThreeJS creates hollow cylinders directly with CylinderGeometry\n- OpenSCAD requires difference() operation between two cylinders\n- Need to match the resolution/smoothness using $fn parameter\n\n4. Positioning Strategy:\n- Model will be centered at origin\n- No additional positioning needed\n- Vertical orientation matches ThreeJS\n\n5. Conversion Process:\n- Create two cylinders: outer and inner\n- Use difference() to subtract inner from outer\n- Set appropriate $fn value to match ThreeJS smoothness\n- Use variables for all dimensions to maintain flexibility\n</conversion_analysis>\n\n<openscad_output>\n// Hollow Cylinder Model\n// Original dimensions preserved from ThreeJS version\n\n// Parameters\nouter_radius = 20;    // Outer radius\nwall_thickness = 5;   // Wall thickness\nheight = 40;         // Height\n$fn = 128;           // Smoothness factor (equivalent to ThreeJS 32 segments)\n\n// Module for hollow cylinder\nmodule hollow_cylinder(outer_r, inner_r, h) {\n    difference() {\n        // Outer cylinder\n        cylinder(r = outer_r, h = h, center = true);\n        \n        // Inner cylinder (slightly taller to ensure clean difference)\n        cylinder(r = inner_r, h = h + 1, center = true);\n    }\n}\n\n// Create the hollow cylinder\nhollow_cylinder(\n    outer_r = outer_radius,\n    inner_r = outer_radius - wall_thickness,\n    h = height\n);\n</openscad_output>\n</ideal_output>\n</example>\n</examples>\n\n"
                },
                {
                    "type": "text",
                    "text": f"You are an expert 3D modeling programmer tasked with converting ThreeJS code representations of 3D models into equivalent OpenSCAD code. Your goal is to create an accurate and efficient OpenSCAD model that maintains the structural integrity and proportions of the original ThreeJS model.\n\nHere is the ThreeJS output that was generated based on the original prompt:\n<threejs_output>\n{threejs_output}\n</threejs_output>\n\nAnd here is the original prompt that was used to generate the ThreeJS code:\n<original_prompt>\n{original_prompt}\n</original_prompt>\n\nTo complete this conversion task, follow these steps:\n\n1. Analyze the ThreeJS code:\n   - Identify all components of the 3D model\n   - Note the dimensions and positions of each component\n   - Understand the relationships between different parts\n\n2. Convert to OpenSCAD:\n   - Use OpenSCAD's primitive shapes (cube, cylinder, sphere) to represent the components\n   - Apply OpenSCAD's transformations (translate, rotate, scale) to position the components correctly\n   - Implement OpenSCAD's Boolean operations (union, difference, intersection) to combine or modify shapes as needed\n   - Convert all dimensions from centimeters to millimeters\n   - Use variables for dimensions to improve readability and modifiability\n   - Group related components using modules\n\n3. Implement OpenSCAD-specific features:\n   - Use the `$fn` variable to control the resolution of curved surfaces\n   - Utilize the `hull()` function for complex shapes if necessary\n   - Implement `minkowski()` for rounded edges if applicable\n\n4. Optimize the code:\n   - Use loops for repetitive elements (e.g., table legs, chair spindles)\n   - Create reusable modules for components that appear multiple times\n\n5. Add clear and concise comments to explain the purpose of each section and any complex operations\n\nBefore generating the final OpenSCAD code, wrap your conversion analysis inside <conversion_analysis> tags. In this analysis:\n\n1. Break down the ThreeJS code structure\n2. List key components and their dimensions and positions\n3. Identify potential challenges in conversion, especially regarding positioning and complex shapes\n4. Outline a strategy for recreating the positioning logic in OpenSCAD\n5. Explain your overall conversion process, addressing any challenges you encounter\n\nPay special attention to accurately recreating the positioning logic from the ThreeJS code.\n\nProvide your final OpenSCAD code inside <openscad_output> tags.\n\nRemember to focus on recreating the geometry and structure of the 3D model, as OpenSCAD does not directly support materials, textures, or lighting."
                },
                {
                    "type": "image",
                    "source": {
                        "type": "base64",
                        "media_type": image_media_type,
                        "data": image_data
                    }
                }
            ]
        },
        {
            "role": "assistant",
            "content": [
                {
                    "type": "text",
                    "text": "<conversion_analysis>"
                }
            ]
        }
    ]
)
print(message.content)