threejs_gen = [
    lambda: {
        "type": "text",
        "text": "<examples>\n<example>\n<description>\nGenerate a model of a hollow cylinder with a 5mm wall thickness\n</description>\n<ideal_output>\n<model_planning>\n1. Extract features and relationships:\n   - Shape: cylinder (hollow)\n   - Outer radius: 20 units\n   - Wall thickness: 5 units\n   - Height: 40 units\n   - Relationship: cylinder is centered\n\n2. Organize features into a structured plan:\n   a. Create a scene, camera, and renderer\n   b. Create a hollow cylinder using THREE.CylinderGeometry\n   c. Position the cylinder at the center of the scene\n   d. Set up lighting\n   e. Set up animation loop\n\n3. Basic structure of the Three.js script:\n   - Import Three.js library\n   - Set up scene, camera, and renderer\n   - Create cylinder geometry and material\n   - Add cylinder to the scene\n   - Set up lighting\n   - Define animation loop\n   - Handle window resizing\n\n4. Materials and textures:\n   - Use MeshStandardMaterial for realistic lighting and shadows\n   - Apply a metallic texture to give the cylinder a realistic appearance\n\n5. Lighting setup:\n   - Add ambient light for overall illumination\n   - Add directional light for shadows and depth\n   - Add point light inside the cylinder to highlight the hollow nature\n\n6. Potential animations:\n   - Rotate the cylinder to showcase its hollow structure\n\n7. Potential challenges and solutions:\n   - Creating a hollow cylinder: Use THREE.CylinderGeometry with inner radius\n   - Ensuring the hollow part is visible: Use camera controls to allow user interaction\n\n8. Summary of structured plan:\n   The plan involves creating a scene with a hollow cylinder using Three.js. The cylinder will have an outer radius of 20 units, a wall thickness of 5 units, and a height of 40 units. It will be centered in the scene and use a metallic material. Lighting will be set up to properly illuminate the model, including the hollow interior. An animation will be added to rotate the model, and camera controls will allow for user interaction to better visualize the hollow structure.\n</model_planning>\n\n<threejs_output>\n// Hollow Cylinder Model\n// Dimensions: Outer radius 20 units, Wall thickness 5 units, Height 40 units\n\n// Scene setup\nconst scene = new THREE.Scene();\nconst camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\nconst renderer = new THREE.WebGLRenderer();\nrenderer.setSize(window.innerWidth, window.innerHeight);\ndocument.body.appendChild(renderer.domElement);\n\n// Cylinder\nconst outerRadius = 20;\nconst innerRadius = 15; // outer radius - wall thickness\nconst height = 40;\nconst radialSegments = 32;\nconst cylinderGeometry = new THREE.CylinderGeometry(outerRadius, outerRadius, height, radialSegments, 1, true, 0, Math.PI * 2);\nconst cylinderMaterial = new THREE.MeshStandardMaterial({ \n  color: 0x888888, \n  metalness: 0.8,\n  roughness: 0.2,\n  side: THREE.DoubleSide\n});\nconst cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);\nscene.add(cylinder);\n\n// Lighting\nconst ambientLight = new THREE.AmbientLight(0x404040);\nscene.add(ambientLight);\nconst directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);\ndirectionalLight.position.set(1, 1, 1);\nscene.add(directionalLight);\nconst pointLight = new THREE.PointLight(0xffffff, 0.5);\npointLight.position.set(0, 0, 0);\nscene.add(pointLight);\n\n// Camera position\ncamera.position.z = 100;\n\n// Orbit controls\nconst controls = new THREE.OrbitControls(camera, renderer.domElement);\n\n// Animation\nfunction animate() {\n  requestAnimationFrame(animate);\n  cylinder.rotation.y += 0.01;\n  controls.update();\n  renderer.render(scene, camera);\n}\nanimate();\n\n// Handle window resizing\nwindow.addEventListener('resize', function() {\n  camera.aspect = window.innerWidth / window.innerHeight;\n  camera.updateProjectionMatrix();\n  renderer.setSize(window.innerWidth, window.innerHeight);\n});\n</threejs_output>\n</ideal_output>\n</example>\n<example>\n<description>\nCreate a dining table\n</description>\n<ideal_output>\n<model_planning>\n1. Extract features and relationships:\n   - Main components: tabletop, legs, support structure\n   - Standard dining table dimensions:\n     * Tabletop: ~150cm length, ~90cm width, ~4cm thickness\n     * Height: ~75cm (standard dining height)\n     * Legs: ~8cm square thickness\n     * Support rails: ~5cm height, ~3cm thickness\n     * Support positioning: ~20cm below tabletop\n\n2. Organize features into a structured plan:\n   a. Create a scene, camera, and renderer\n   b. Create tabletop as a BoxGeometry\n   c. Create four legs as BoxGeometry\n   d. Create support rails as BoxGeometry\n   e. Group all components into a single Object3D\n   f. Position components correctly\n   g. Set up lighting\n   h. Set up animation loop and controls\n\n3. Basic structure of Three.js script:\n   - Import Three.js library\n   - Set up scene, camera, and renderer\n   - Define all dimensional variables\n   - Create functions for table components (tabletop, leg, support rail)\n   - Create and position all components\n   - Group components into a table object\n   - Set up lighting\n   - Set up orbit controls for interaction\n   - Define animation loop\n   - Handle window resizing\n\n4. Materials and textures:\n   - Use MeshStandardMaterial for realistic lighting and shadows\n   - Apply wood texture to all components\n\n5. Lighting setup:\n   - Add ambient light for overall illumination\n   - Add directional light for shadows and depth\n   - Add point lights to highlight details\n\n6. Potential animations:\n   - Rotate the table to showcase its structure\n   - Allow user interaction with orbit controls\n\n7. Potential challenges and solutions:\n   - Correct positioning of components: Use careful calculations and Three.js positioning\n   - Realistic wood appearance: Use texture mapping\n   - Performance with complex geometry: Use appropriate level of detail\n\n8. Summary of structured plan:\n   Create a Three.js scene with a dining table, including tabletop, legs, and support structure. Use realistic dimensions and wood textures. Set up proper lighting to showcase the table's features. Implement orbit controls for user interaction and add subtle animation to rotate the table.\n</model_planning>\n\n<threejs_output>\n// Dining Table Model\n// All dimensions in centimeters\n\n// Scene setup\nconst scene = new THREE.Scene();\nconst camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\nconst renderer = new THREE.WebGLRenderer();\nrenderer.setSize(window.innerWidth, window.innerHeight);\ndocument.body.appendChild(renderer.domElement);\n\n// Dimensions\nconst tableLength = 150;\nconst tableWidth = 90;\nconst tableHeight = 75;\nconst topThickness = 4;\nconst legWidth = 8;\nconst legInset = 5;\nconst supportHeight = 5;\nconst supportThickness = 3;\n\n// Materials\nconst woodTexture = new THREE.TextureLoader().load('wood_texture.jpg');\nconst woodMaterial = new THREE.MeshStandardMaterial({ map: woodTexture });\n\n// Table components\nfunction createTabletop() {\n  const geometry = new THREE.BoxGeometry(tableLength, topThickness, tableWidth);\n  return new THREE.Mesh(geometry, woodMaterial);\n}\n\nfunction createLeg() {\n  const geometry = new THREE.BoxGeometry(legWidth, tableHeight - topThickness, legWidth);\n  return new THREE.Mesh(geometry, woodMaterial);\n}\n\nfunction createSupportRail(length) {\n  const geometry = new THREE.BoxGeometry(length, supportHeight, supportThickness);\n  return new THREE.Mesh(geometry, woodMaterial);\n}\n\n// Create table\nconst table = new THREE.Object3D();\n\n// Tabletop\nconst tabletop = createTabletop();\ntabletop.position.y = tableHeight - topThickness / 2;\ntable.add(tabletop);\n\n// Legs\nconst legPositions = [\n  { x: -tableLength/2 + legInset + legWidth/2, z: -tableWidth/2 + legInset + legWidth/2 },\n  { x: tableLength/2 - legInset - legWidth/2, z: -tableWidth/2 + legInset + legWidth/2 },\n  { x: -tableLength/2 + legInset + legWidth/2, z: tableWidth/2 - legInset - legWidth/2 },\n  { x: tableLength/2 - legInset - legWidth/2, z: tableWidth/2 - legInset - legWidth/2 }\n];\n\nlegPositions.forEach(pos => {\n  const leg = createLeg();\n  leg.position.set(pos.x, (tableHeight - topThickness) / 2, pos.z);\n  table.add(leg);\n});\n\n// Support rails\nconst longRailLength = tableLength - 2 * legInset - 2 * legWidth;\nconst shortRailLength = tableWidth - 2 * legInset - 2 * legWidth;\n\nconst longRailPositions = [\n  { x: 0, z: -tableWidth/2 + legInset + legWidth/2 },\n  { x: 0, z: tableWidth/2 - legInset - legWidth/2 }\n];\n\nconst shortRailPositions = [\n  { x: -tableLength/2 + legInset + legWidth/2, z: 0 },\n  { x: tableLength/2 - legInset - legWidth/2, z: 0 }\n];\n\nlongRailPositions.forEach(pos => {\n  const rail = createSupportRail(longRailLength);\n  rail.position.set(pos.x, tableHeight - topThickness - supportHeight - 20, pos.z);\n  table.add(rail);\n});\n\nshortRailPositions.forEach(pos => {\n  const rail = createSupportRail(shortRailLength);\n  rail.rotation.y = Math.PI / 2;\n  rail.position.set(pos.x, tableHeight - topThickness - supportHeight - 20, pos.z);\n  table.add(rail);\n});\n\nscene.add(table);\n\n// Lighting\nconst ambientLight = new THREE.AmbientLight(0x404040);\nscene.add(ambientLight);\n\nconst directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);\ndirectionalLight.position.set(1, 1, 1);\nscene.add(directionalLight);\n\nconst pointLight1 = new THREE.PointLight(0xffffff, 0.5);\npointLight1.position.set(0, 100, 0);\nscene.add(pointLight1);\n\nconst pointLight2 = new THREE.PointLight(0xffffff, 0.3);\npointLight2.position.set(100, 0, 100);\nscene.add(pointLight2);\n\n// Camera position\ncamera.position.set(150, 100, 150);\ncamera.lookAt(scene.position);\n\n// Orbit controls\nconst controls = new THREE.OrbitControls(camera, renderer.domElement);\n\n// Animation\nfunction animate() {\n  requestAnimationFrame(animate);\n  table.rotation.y += 0.002;\n  controls.update();\n  renderer.render(scene, camera);\n}\nanimate();\n\n// Handle window resizing\nwindow.addEventListener('resize', function() {\n  camera.aspect = window.innerWidth / window.innerHeight;\n  camera.updateProjectionMatrix();\n  renderer.setSize(window.innerWidth, window.innerHeight);\n});\n</threejs_output>\n</ideal_output>\n</example>\n</examples>\n\n",
    },
    lambda description: {
        "type": "text",
        "text": f"You are Imagine3D, an expert AI assistant specializing in generating accurate, error-free Three.js scripts based on textual descriptions or images of 3D objects. Your task is to create precise, functional 3D models that can be directly used in a Three.js environment.\n\nHere is the description of the 3D object you need to model:\n\n<description>\n{description}\n</description>\n\nPlease follow these guidelines to create the Three.js script:\n\n1. Analyze the Input:\n   - For textual descriptions, carefully extract all dimensions, shapes, features, and spatial relationships.\n   - For images, if mentioned, interpret the 3D structure as accurately as possible.\n\n2. Use Three.js Best Practices:\n   - Use valid Three.js syntax only.\n   - Utilize appropriate geometries, materials, and lighting.\n   - Ensure the scene is properly set up with camera and renderer.\n   - Avoid redundant or unused components in the script.\n   - Ensure readability and maintainability.\n\n3. Dimensions and Units:\n   - Use appropriate units for Three.js (typically scene units).\n   - If units are ambiguous, make reasonable assumptions based on context.\n   - When given ranges, use random but realistic values within the specified range.\n\n4. Script Structure:\n   - Use 2 spaces for indentation.\n   - Organize the script into logical sections:\n     a. Scene, camera, and renderer setup\n     b. Geometry and material creation\n     c. Object positioning and scaling\n     d. Lighting setup\n     e. Animation (if applicable)\n     f. Render loop\n\n5. Verification:\n   - Check for syntax errors.\n   - Ensure all objects and variables are used correctly.\n   - Validate that the generated script will execute without additional user input.\n\nBefore generating the final output, wrap your model planning inside <model_planning> tags:\n1. Extract all features and relationships from the input.\n2. Organize these features into a structured plan for the Three.js model.\n3. Sketch out the basic structure of the Three.js script, including main objects and functions.\n4. Plan out the materials and textures to be used for each part of the model.\n5. Design the lighting setup, including type, position, and intensity of lights.\n6. Consider potential animations or interactive elements that could enhance the model.\n7. Identify potential challenges in implementing the model and how to address them.\n8. Summarize the structured plan to ensure alignment with the user's intent.\n\nProvide your ThreeJS code inside <threejs_output> tags. \n\nRemember to provide a complete, executable Three.js script that can be directly copied and pasted into a web environment without errors.",
    },
    lambda image_data, image_media_type: {
        "type": "image",
        "source": {
            "type": "base64",
            "media_type": image_media_type,
            "data": image_data,
        },
    },
]

threejs_to_openscad = [
    lambda: {
        "type": "text",
        "text": "<examples>\n<example>\n<THREEJS_OUTPUT>\n// Dining Table Model\n// All dimensions in centimeters\n\n// Scene setup\nconst scene = new THREE.Scene();\nconst camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\nconst renderer = new THREE.WebGLRenderer();\nrenderer.setSize(window.innerWidth, window.innerHeight);\ndocument.body.appendChild(renderer.domElement);\n\n// Dimensions\nconst tableLength = 150;\nconst tableWidth = 90;\nconst tableHeight = 75;\nconst topThickness = 4;\nconst legWidth = 8;\nconst legInset = 5;\nconst supportHeight = 5;\nconst supportThickness = 3;\n\n// Materials\nconst woodTexture = new THREE.TextureLoader().load('wood_texture.jpg');\nconst woodMaterial = new THREE.MeshStandardMaterial({ map: woodTexture });\n\n// Table components\nfunction createTabletop() {\n  const geometry = new THREE.BoxGeometry(tableLength, topThickness, tableWidth);\n  return new THREE.Mesh(geometry, woodMaterial);\n}\n\nfunction createLeg() {\n  const geometry = new THREE.BoxGeometry(legWidth, tableHeight - topThickness, legWidth);\n  return new THREE.Mesh(geometry, woodMaterial);\n}\n\nfunction createSupportRail(length) {\n  const geometry = new THREE.BoxGeometry(length, supportHeight, supportThickness);\n  return new THREE.Mesh(geometry, woodMaterial);\n}\n\n// Create table\nconst table = new THREE.Object3D();\n\n// Tabletop\nconst tabletop = createTabletop();\ntabletop.position.y = tableHeight - topThickness / 2;\ntable.add(tabletop);\n\n// Legs\nconst legPositions = [\n  { x: -tableLength/2 + legInset + legWidth/2, z: -tableWidth/2 + legInset + legWidth/2 },\n  { x: tableLength/2 - legInset - legWidth/2, z: -tableWidth/2 + legInset + legWidth/2 },\n  { x: -tableLength/2 + legInset + legWidth/2, z: tableWidth/2 - legInset - legWidth/2 },\n  { x: tableLength/2 - legInset - legWidth/2, z: tableWidth/2 - legInset - legWidth/2 }\n];\n\nlegPositions.forEach(pos => {\n  const leg = createLeg();\n  leg.position.set(pos.x, (tableHeight - topThickness) / 2, pos.z);\n  table.add(leg);\n});\n\n// Support rails\nconst longRailLength = tableLength - 2 * legInset - 2 * legWidth;\nconst shortRailLength = tableWidth - 2 * legInset - 2 * legWidth;\n\nconst longRailPositions = [\n  { x: 0, z: -tableWidth/2 + legInset + legWidth/2 },\n  { x: 0, z: tableWidth/2 - legInset - legWidth/2 }\n];\n\nconst shortRailPositions = [\n  { x: -tableLength/2 + legInset + legWidth/2, z: 0 },\n  { x: tableLength/2 - legInset - legWidth/2, z: 0 }\n];\n\nlongRailPositions.forEach(pos => {\n  const rail = createSupportRail(longRailLength);\n  rail.position.set(pos.x, tableHeight - topThickness - supportHeight - 20, pos.z);\n  table.add(rail);\n});\n\nshortRailPositions.forEach(pos => {\n  const rail = createSupportRail(shortRailLength);\n  rail.rotation.y = Math.PI / 2;\n  rail.position.set(pos.x, tableHeight - topThickness - supportHeight - 20, pos.z);\n  table.add(rail);\n});\n\nscene.add(table);\n\n// Lighting\nconst ambientLight = new THREE.AmbientLight(0x404040);\nscene.add(ambientLight);\n\nconst directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);\ndirectionalLight.position.set(1, 1, 1);\nscene.add(directionalLight);\n\nconst pointLight1 = new THREE.PointLight(0xffffff, 0.5);\npointLight1.position.set(0, 100, 0);\nscene.add(pointLight1);\n\nconst pointLight2 = new THREE.PointLight(0xffffff, 0.3);\npointLight2.position.set(100, 0, 100);\nscene.add(pointLight2);\n\n// Camera position\ncamera.position.set(150, 100, 150);\ncamera.lookAt(scene.position);\n\n// Orbit controls\nconst controls = new THREE.OrbitControls(camera, renderer.domElement);\n\n// Animation\nfunction animate() {\n  requestAnimationFrame(animate);\n  table.rotation.y += 0.002;\n  controls.update();\n  renderer.render(scene, camera);\n}\nanimate();\n\n// Handle window resizing\nwindow.addEventListener('resize', function() {\n  camera.aspect = window.innerWidth / window.innerHeight;\n  camera.updateProjectionMatrix();\n  renderer.setSize(window.innerWidth, window.innerHeight);\n});\n</THREEJS_OUTPUT>\n<ORIGINAL_PROMPT>\nCreate a dining table\n</ORIGINAL_PROMPT>\n<ideal_output>\n<conversion_analysis>\n1. ThreeJS Code Structure Breakdown:\n   - Scene setup (camera, renderer)\n   - Dimension definitions\n   - Material setup (wood texture)\n   - Table component functions (tabletop, leg, support rail)\n   - Table assembly\n   - Lighting setup\n   - Camera positioning and controls\n   - Animation loop\n\n2. Key Components and Dimensions:\n   - Tabletop: 150cm x 90cm x 4cm\n   - Legs: 8cm x 8cm x 71cm (4 pieces)\n   - Support Rails: Long (126cm) and Short (66cm)\n   - Table Height: 75cm\n\n3. Potential Conversion Challenges:\n   - Coordinate system differences (ThreeJS uses center origin, OpenSCAD typically uses corner origin)\n   - Complex positioning of legs and support rails\n   - No direct equivalent for materials and lighting in OpenSCAD\n\n4. Positioning Logic Strategy:\n   - Convert ThreeJS center-origin coordinates to OpenSCAD corner-origin\n   - Carefully calculate leg positions relative to table edges\n   - Position support rails using the same logic as in ThreeJS\n\n5. Overall Conversion Process:\n   - Define all dimensions as variables, converting cm to mm\n   - Create modules for repeated components (legs, rails)\n   - Use translate() to position components accurately\n   - Implement positioning logic that matches ThreeJS coordinates\n   - Use union() to combine all components into a single model\n</conversion_analysis>\n\n<model_planning>\nConversion Process and Challenges:\n\n1. Dimension Conversion:\n- Converted all dimensions from centimeters to millimeters\n- Maintained the same proportions as the original ThreeJS model\n\n2. Structural Changes:\n- Replaced ThreeJS's mesh-based approach with OpenSCAD's constructive solid geometry (CSG)\n- Used basic cube primitives for all components as they matched the original geometric shapes\n- Implemented modules for reusable components (legs and support rails)\n\n3. Main Challenges:\n- Coordinate System Differences: Had to adjust the positioning logic since OpenSCAD uses a different coordinate system than ThreeJS\n- Position Calculations: Needed to carefully calculate the positions of legs and support rails relative to the table dimensions\n- No Direct Material Support: Removed material and texture information as OpenSCAD doesn't support these features\n\n4. Optimizations:\n- Used a loop for creating table legs instead of individual placement\n- Created modular components for better code organization and reusability\n- Added variables for all dimensions to make the design easily modifiable\n\n5. Additional Considerations:\n- Added $fn variable for controlling curve resolution (though not strictly necessary for this model)\n- Organized code with clear sections and comments for better readability\n- Positioned the entire model in positive coordinate space for easier 3D printing if needed\n\nThe resulting OpenSCAD model maintains the same structural integrity and proportions as the original ThreeJS model, though without the visual elements like materials and lighting.\n</model_planning>\n\n<openscad_output>\n// Dining Table in OpenSCAD\n// All dimensions in millimeters (converted from cm)\n\n// Global resolution\n$fn = 50;\n\n// Table dimensions\ntableLength = 1500; // 150cm\ntableWidth = 900;   // 90cm\ntableHeight = 750;  // 75cm\ntopThickness = 40;  // 4cm\nlegWidth = 80;      // 8cm\nlegInset = 50;      // 5cm\nsupportHeight = 50;  // 5cm\nsupportThickness = 30; // 3cm\n\n// Module for table leg\nmodule table_leg() {\n    cube([legWidth, legWidth, tableHeight - topThickness]);\n}\n\n// Module for support rail\nmodule support_rail(length) {\n    cube([length, supportThickness, supportHeight]);\n}\n\n// Module for complete table\nmodule dining_table() {\n    // Tabletop\n    translate([-tableLength/2, -tableWidth/2, tableHeight - topThickness])\n        cube([tableLength, tableWidth, topThickness]);\n    \n    // Legs\n    leg_positions = [\n        [-tableLength/2 + legInset, -tableWidth/2 + legInset, 0],\n        [tableLength/2 - legInset - legWidth, -tableWidth/2 + legInset, 0],\n        [-tableLength/2 + legInset, tableWidth/2 - legInset - legWidth, 0],\n        [tableLength/2 - legInset - legWidth, tableWidth/2 - legInset - legWidth, 0]\n    ];\n    \n    for (pos = leg_positions) {\n        translate(pos) table_leg();\n    }\n    \n    // Support rails\n    longRailLength = tableLength - 2 * legInset - 2 * legWidth;\n    shortRailLength = tableWidth - 2 * legInset - 2 * legWidth;\n    railHeight = tableHeight - topThickness - supportHeight - 200; // 20cm below top\n    \n    // Long rails\n    translate([-longRailLength/2, -tableWidth/2 + legInset + legWidth/2 - supportThickness/2, railHeight])\n        support_rail(longRailLength);\n    translate([-longRailLength/2, tableWidth/2 - legInset - legWidth/2 - supportThickness/2, railHeight])\n        support_rail(longRailLength);\n    \n    // Short rails\n    translate([-tableLength/2 + legInset + legWidth/2 - supportThickness/2, -shortRailLength/2, railHeight])\n        rotate([0, 0, 90])\n            support_rail(shortRailLength);\n    translate([tableLength/2 - legInset - legWidth/2 - supportThickness/2, -shortRailLength/2, railHeight])\n        rotate([0, 0, 90])\n            support_rail(shortRailLength);\n}\n\n// Create the table\ndining_table();\n</openscad_output>\n</ideal_output>\n</example>\n<example>\n<THREEJS_OUTPUT>\n// Hollow Cylinder Model\n// Dimensions: Outer radius 20 units, Wall thickness 5 units, Height 40 units\n\n// Scene setup\nconst scene = new THREE.Scene();\nconst camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\nconst renderer = new THREE.WebGLRenderer();\nrenderer.setSize(window.innerWidth, window.innerHeight);\ndocument.body.appendChild(renderer.domElement);\n\n// Cylinder\nconst outerRadius = 20;\nconst innerRadius = 15; // outer radius - wall thickness\nconst height = 40;\nconst radialSegments = 32;\nconst cylinderGeometry = new THREE.CylinderGeometry(outerRadius, outerRadius, height, radialSegments, 1, true, 0, Math.PI * 2);\nconst cylinderMaterial = new THREE.MeshStandardMaterial({ \n  color: 0x888888, \n  metalness: 0.8,\n  roughness: 0.2,\n  side: THREE.DoubleSide\n});\nconst cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);\nscene.add(cylinder);\n\n// Lighting\nconst ambientLight = new THREE.AmbientLight(0x404040);\nscene.add(ambientLight);\nconst directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);\ndirectionalLight.position.set(1, 1, 1);\nscene.add(directionalLight);\nconst pointLight = new THREE.PointLight(0xffffff, 0.5);\npointLight.position.set(0, 0, 0);\nscene.add(pointLight);\n\n// Camera position\ncamera.position.z = 100;\n\n// Orbit controls\nconst controls = new THREE.OrbitControls(camera, renderer.domElement);\n\n// Animation\nfunction animate() {\n  requestAnimationFrame(animate);\n  cylinder.rotation.y += 0.01;\n  controls.update();\n  renderer.render(scene, camera);\n}\nanimate();\n\n// Handle window resizing\nwindow.addEventListener('resize', function() {\n  camera.aspect = window.innerWidth / window.innerHeight;\n  camera.updateProjectionMatrix();\n  renderer.setSize(window.innerWidth, window.innerHeight);\n});\n</THREEJS_OUTPUT>\n<ORIGINAL_PROMPT>\nGenerate a model of a hollow cylinder with a 5mm wall thickness\n</ORIGINAL_PROMPT>\n<ideal_output>\n<conversion_analysis>\n1. ThreeJS Code Structure Breakdown:\n- Main geometric element is a hollow cylinder\n- Uses CylinderGeometry with both outer and inner radius\n- Key dimensions: \n  * Outer radius: 20 units\n  * Inner radius: 15 units (derived from 5-unit wall thickness)\n  * Height: 40 units\n  * 32 radial segments for smooth cylindrical surface\n\n2. Key Components:\n- Single hollow cylinder created using CylinderGeometry\n- No complex positioning needed as it's centered at origin\n- Material properties (not relevant for OpenSCAD conversion)\n\n3. Conversion Challenges:\n- ThreeJS creates hollow cylinders directly with CylinderGeometry\n- OpenSCAD requires difference() operation between two cylinders\n- Need to match the resolution/smoothness using $fn parameter\n\n4. Positioning Strategy:\n- Model will be centered at origin\n- No additional positioning needed\n- Vertical orientation matches ThreeJS\n\n5. Conversion Process:\n- Create two cylinders: outer and inner\n- Use difference() to subtract inner from outer\n- Set appropriate $fn value to match ThreeJS smoothness\n- Use variables for all dimensions to maintain flexibility\n</conversion_analysis>\n\n<openscad_output>\n// Hollow Cylinder Model\n// Original dimensions preserved from ThreeJS version\n\n// Parameters\nouter_radius = 20;    // Outer radius\nwall_thickness = 5;   // Wall thickness\nheight = 40;         // Height\n$fn = 128;           // Smoothness factor (equivalent to ThreeJS 32 segments)\n\n// Module for hollow cylinder\nmodule hollow_cylinder(outer_r, inner_r, h) {\n    difference() {\n        // Outer cylinder\n        cylinder(r = outer_r, h = h, center = true);\n        \n        // Inner cylinder (slightly taller to ensure clean difference)\n        cylinder(r = inner_r, h = h + 1, center = true);\n    }\n}\n\n// Create the hollow cylinder\nhollow_cylinder(\n    outer_r = outer_radius,\n    inner_r = outer_radius - wall_thickness,\n    h = height\n);\n</openscad_output>\n</ideal_output>\n</example>\n</examples>\n\n",
    },
    lambda threejs_output, original_prompt: {
        "type": "text",
        "text": f"You are an expert 3D modeling programmer tasked with converting ThreeJS code representations of 3D models into equivalent OpenSCAD code. Your goal is to create an accurate and efficient OpenSCAD model that maintains the structural integrity and proportions of the original ThreeJS model.\n\nHere is the ThreeJS output that was generated based on the original prompt:\n<threejs_output>\n{threejs_output}\n</threejs_output>\n\nAnd here is the original prompt that was used to generate the ThreeJS code:\n<original_prompt>\n{original_prompt}\n</original_prompt>\n\nTo complete this conversion task, follow these steps:\n\n1. Analyze the ThreeJS code:\n   - Identify all components of the 3D model\n   - Note the dimensions and positions of each component\n   - Understand the relationships between different parts\n\n2. Convert to OpenSCAD:\n   - Use OpenSCAD's primitive shapes (cube, cylinder, sphere) to represent the components\n   - Apply OpenSCAD's transformations (translate, rotate, scale) to position the components correctly\n   - Implement OpenSCAD's Boolean operations (union, difference, intersection) to combine or modify shapes as needed\n   - Convert all dimensions from centimeters to millimeters\n   - Use variables for dimensions to improve readability and modifiability\n   - Group related components using modules\n\n3. Implement OpenSCAD-specific features:\n   - Use the `$fn` variable to control the resolution of curved surfaces\n   - Utilize the `hull()` function for complex shapes if necessary\n   - Implement `minkowski()` for rounded edges if applicable\n\n4. Optimize the code:\n   - Use loops for repetitive elements (e.g., table legs, chair spindles)\n   - Create reusable modules for components that appear multiple times\n\n5. Add clear and concise comments to explain the purpose of each section and any complex operations\n\nBefore generating the final OpenSCAD code, wrap your conversion analysis inside <conversion_analysis> tags. In this analysis:\n\n1. Break down the ThreeJS code structure\n2. List key components and their dimensions and positions\n3. Identify potential challenges in conversion, especially regarding positioning and complex shapes\n4. Outline a strategy for recreating the positioning logic in OpenSCAD\n5. Explain your overall conversion process, addressing any challenges you encounter\n\nPay special attention to accurately recreating the positioning logic from the ThreeJS code.\n\nProvide your final OpenSCAD code inside <openscad_output> tags.\n\nRemember to focus on recreating the geometry and structure of the 3D model, as OpenSCAD does not directly support materials, textures, or lighting.",
    },
    lambda image_data, image_media_type: {
        "type": "image",
        "source": {
            "type": "base64",
            "media_type": image_media_type,
            "data": image_data,
        },
    },
]

followup = [
    lambda original_prompt, openscad_output, instructions: {
        "type": "text",
        "text": f"You are an AI assistant tasked with modifying OpenSCAD scripts based on user instructions. Your goal is to understand the original design, interpret the user's modification requests, and update the script accordingly.\n\nHere's the original prompt used to generate the OpenSCAD script:\n<original_prompt>\n{original_prompt}\n</original_prompt>\n\nHere's the current OpenSCAD script:\n<openscad_script>\n{openscad_output}\n</openscad_script>\n\nThe user has provided the following instructions for modifying the script:\n<user_instructions>\n{instructions}\n</user_instructions>\n\nTo modify the script, follow these steps:\n\n1. Carefully analyze the original prompt and the current OpenSCAD script to understand the design's purpose and structure.\n\n2. Review the user's modification instructions and identify the specific changes requested.\n\n3. Make the necessary modifications to the OpenSCAD script, ensuring that:\n   a. The changes align with the user's instructions\n   b. The overall structure and functionality of the script remain intact\n   c. The modifications are implemented efficiently and logically\n\n4. If any requested modifications are unclear, impossible, or conflict with the original design, make your best judgment to interpret and implement them. Note these instances for later explanation.\n\n5. After making the modifications, review the entire script to ensure consistency and proper functionality.\n\nPresent your modified OpenSCAD script within <modified_script> tags.\n\nAfter the modified script, provide an explanation of the changes you made and any potential issues or considerations within <explanation> tags. Include:\n- A summary of the modifications implemented\n- Any assumptions or interpretations you made regarding unclear instructions\n- Potential impacts on the model's functionality or appearance\n- Any parts of the user's instructions that couldn't be implemented, and why\n\nIf you encounter any errors or issues while modifying the script, explain them within <issues> tags after your explanation.\n\nRemember to maintain the original script's structure and naming conventions where possible, and ensure that your modifications are clear and well-commented.",
    },
    lambda image_media_type, image_data: {
        "type": "image",
        "source": {
            "type": "base64",
            "media_type": image_media_type,
            "data": image_data,
        },
    },
]
